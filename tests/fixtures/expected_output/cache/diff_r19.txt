Index: include/formatter.h
===================================================================
--- include/formatter.h	(nonexistent)
+++ include/formatter.h	(revision 19)
@@ -0,0 +1,20 @@
+﻿#ifndef FORMATTER_H
+#define FORMATTER_H
+
+#include <string>
+
+namespace ninja {
+
+class Formatter {
+public:
+    enum class Style { FIXED, SCIENTIFIC, AUTO };
+
+    static std::string format(double value, Style style = Style::AUTO, int precision = 6);
+    static std::string formatWithCommas(double value);
+    static std::string formatPercent(double value, int precision = 2);
+    static std::string formatBytes(long long bytes);
+};
+
+} // namespace ninja
+
+#endif // FORMATTER_H
\ No newline at end of file
Index: src/formatter.cpp
===================================================================
--- src/formatter.cpp	(nonexistent)
+++ src/formatter.cpp	(revision 19)
@@ -0,0 +1,73 @@
+﻿#include <string>
+#include <sstream>
+#include <iomanip>
+#include <cmath>
+#include <vector>
+#include <algorithm>
+
+namespace ninja {
+
+class Formatter {
+public:
+    enum class Style { FIXED, SCIENTIFIC, AUTO };
+
+    static std::string format(double value, Style style = Style::AUTO, int precision = 6) {
+        std::ostringstream oss;
+        switch (style) {
+            case Style::FIXED:
+                oss << std::fixed << std::setprecision(precision) << value;
+                break;
+            case Style::SCIENTIFIC:
+                oss << std::scientific << std::setprecision(precision) << value;
+                break;
+            case Style::AUTO:
+                if (std::abs(value) > 1e6 || (std::abs(value) < 1e-4 && value != 0)) {
+                    oss << std::scientific << std::setprecision(precision) << value;
+                } else {
+                    oss << std::fixed << std::setprecision(precision) << value;
+                    // Remove trailing zeros
+                    std::string s = oss.str();
+                    size_t dot = s.find('.');
+                    if (dot != std::string::npos) {
+                        size_t last = s.find_last_not_of('0');
+                        if (last == dot) last++;
+                        return s.substr(0, last + 1);
+                    }
+                    return s;
+                }
+                break;
+        }
+        return oss.str();
+    }
+
+    static std::string formatWithCommas(double value) {
+        std::string num = std::to_string(static_cast<long long>(value));
+        int insertPos = static_cast<int>(num.length()) - 3;
+        while (insertPos > 0) {
+            num.insert(insertPos, ",");
+            insertPos -= 3;
+        }
+        return num;
+    }
+
+    static std::string formatPercent(double value, int precision = 2) {
+        std::ostringstream oss;
+        oss << std::fixed << std::setprecision(precision) << (value * 100.0) << "%";
+        return oss.str();
+    }
+
+    static std::string formatBytes(long long bytes) {
+        const char* units[] = {"B", "KB", "MB", "GB", "TB"};
+        int unitIdx = 0;
+        double size = static_cast<double>(bytes);
+        while (size >= 1024.0 && unitIdx < 4) {
+            size /= 1024.0;
+            unitIdx++;
+        }
+        std::ostringstream oss;
+        oss << std::fixed << std::setprecision(2) << size << " " << units[unitIdx];
+        return oss.str();
+    }
+};
+
+} // namespace ninja
\ No newline at end of file

